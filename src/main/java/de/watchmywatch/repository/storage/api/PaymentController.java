package de.watchmywatch.repository.storage.api;

import de.watchmywatch.model.OrderManagment.Payment;
import de.watchmywatch.repository.exception.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller // Identifies Class as Controller
@RequestMapping(path="/api") // URL's start with /demo (after Application path)
public class PaymentController {
    @Autowired // This means to get the bean called PaymentRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    public PaymentRepository paymentRepository;

    // GET /api/payments returns all payments
    @GetMapping(path = "/payments")
    public @ResponseBody
    Iterable<Payment> getAllPayments() {
        // This returns a JSON or XML with the users
        return paymentRepository.findAll();
    }

    // GET /api/payment/:id returns payment with id
    @GetMapping(value = "/payment/{paymentId}")
    public @ResponseBody
    Payment getOnePayment(@PathVariable Integer paymentId) {
        // This returns a JSON or XML with the one payment
        return paymentRepository.findById(paymentId)
                .orElseThrow(() -> new NotFoundException("payment", paymentId));
    }

    // POST /api/payment creates a payment in the database and returns "Saved"
    @PostMapping(path = "/payment") // Map ONLY POST Requests
    public @ResponseBody
    String addNewPayment(Payment payment) {
        paymentRepository.save(payment);
        return "Saved";
    }

    // PUT /api/payments/:id updates the payment with the id
    @PutMapping("/payments/{id}")
    public @ResponseBody
    Payment updatePayment(@PathVariable Integer id, @RequestBody Payment newPayment) {
        return paymentRepository.findById(id)
                .map(payment -> {
                    payment.setDatePaid(newPayment.getDatePaid());
                    payment.setPaymentMethod(newPayment.getPaymentMethod());
                    payment.setDetails(newPayment.getDetails());
                    return paymentRepository.save(payment);
                })
                .orElseGet(() -> {
                    newPayment.setId(id);
                    return paymentRepository.save(newPayment);
                });
    }

    // TODO: Change overlapping Paths
    // DELETE /api/payments/:id deletes the payment with id and returns "Deleted"
    @DeleteMapping(path = "/payments/{id}")
    public @ResponseBody
    String updatePayment(@PathVariable Integer id) {
        paymentRepository.deleteById(id);
        return "Deleted";
    }
}